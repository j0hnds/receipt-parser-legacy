# Define the tesseract language
#
language: eng

# Where the receipts are stored
# Receipts should be simple text files
receipts_path: "data/txt"

results_as_json: false

# Market names roughly ordered by likelihood.
# Can contain market locations for fuzzy parsing
markets:
  Safeway:
     - safeway
     - Safeway
     - SAFEWAY
  Boyds:
     - boyds
     - Boyds
     - BOYDS
  Colruyt:
     - colruyt
     - Colruyt
  Delhaize:
     - Delhaize
     - delhaize
  Penny:
     - penny markt
     - penny
     - p e n n y
     - m a r k t gmbh
  REWE:
     - rewe
  Real:
     - real
  Netto:
     - netto-online
  Kaiser's:
     - kaiser
     - kaiserswerther straße 270
  Aldi:
     - aldi
     - friedrichstr 128—133
  Lidl:
     - lidl
  Edeka:
    - edeka
  Drogerie:
     - drogerie
  Kodi:
     - kodi
  Getraenke:
    - Getraenke Tempel
  Tanken:
     - shell
     - esso station
     - aral
     - total tankstelle
     - RK Tankstellen
  Migros:
     - genossenschaft migros
  Metro:
     - vetro
     - metro

# Sum keys roughly ordered by likelyhood.
#
# When scanning for line-items, in the case of any market except 'Metro',
# if one of these words is found on the line, it will stop scanning for
# line items.
sum_keys:
  - total
  - balance
  - summe
  - summe eur
  - gesamtbetrag
  - gesantbetrag
  - gesamt
  - sum
  - zwischensumme
  - bar
  - te betalen
  - rockgeld
  - rusckgeld
  - rückgeld

sum_keys_boyds:
  - total due

# Used when scanning for receipt line-items. If one of these
# words exists anywhere on a line in the receipt, the line on
# which it occurs is skipped. So, useful for cleaning up the
# receipt. Remember, these can be per-market.
ignore_keys:
  - mwst
  - kg x
  - stkx
  - stk
  - zw-summe

# This value will be searched out in the 'Total' line and the
# entire match for the RE will be used as the total. So something
# like 'SUMME EUR 5,03' will result in '5,03'
sum_format: '\d+(\.\s?|,\s?|[^a-zA-Z\d])\d{2}'

# Assumes that the item name is the first capture group
# and the line item cost is the second.
item_format: '([a-zA-Z].+)\s(-|)((\d|\d{2}),(\d{2}|\d{3}))\s'
item_format_metro: '[0-9]\s(.*?)\d.()((\d|\d{2})(\,|\.)\d{1,2})\s([A|a]|[B|b])'
# item_format_boyds: '\d+\s+\d+\.\d{2}\s+\$(\d+\.\d{2})\s+(.*)\s+(.*)(\d+)\s+(\d+\.\d{2})\s+\$(\d+\.\d{2})\s+(.*)\s+(.*)'
item_format_boyds: '\d+\s+\d+\.\d{2}\s+\$(\d+\.\d{2})\s+(.*)'

# Matches dates like 19.08.15 and 19.08.2015
date_format: '(\d{1,2}/\d{1,2}/\d{2,4})'
# date_format: '((\d{2}\.\d{2}\.\d{2,4})|(\d{2,4}\/\d{2}\/\d{2})|(\d{2}\/\d{2}\/\d{4}))'

